#ifndef REGEXTODFACONVERTER_REGEX_TO_DFA_H
#define REGEXTODFACONVERTER_REGEX_TO_DFA_H

#include "dfa.h"
#include <unordered_set>
#include <string>
#include <vector>
#include "dfa.h"
using namespace std;

class RegexToDFAConverter {
 private:
  //forward declaration
  struct SyntaxTreeNode;
 public:
  RegexToDFAConverter() = default;
  RegexToDFAConverter(const RegexToDFAConverter&) = default;
  RegexToDFAConverter& operator=(const RegexToDFAConverter&) = default;
  virtual ~RegexToDFAConverter() = default;

  //converts the regular expression into a DFA
  DFA convert(const string& expr);
 private:
  /*structure that holds information for a node from the syntax tree attributed
   *to the regular expression */
  struct SyntaxTreeNode {
    SyntaxTreeNode() : leaf_index(0), nullable(false) {}
    ~SyntaxTreeNode() { wipe_sons(); }
    void wipe_sons() {
      for (auto it : sons)
        delete it;
      sons.clear();
    }

    vector< SyntaxTreeNode* > sons; //sons in the tree for the current node
    unordered_set< int > first_pos; /*set of positions in the subtree generated
                                     *by the current node, that corresponds to
                                     *the first letter of at least one word from
                                     *the language generated by this subtree of
                                     *the syntax tree */
    unordered_set< int > last_pos; //similar to first_pos, but for last letter
    int leaf_index; //0 if not leaf or leaf with lambda
    bool nullable; /*true iff the subexpression represented by the current node
                    *has the empty string in its language */
  };

  //adds catenation symbol where necessary and appends the end marker
  string simplify(const string& expr);

  //checks if ch is a letter of the alphabet or lambda
  bool is_letter(char ch);

  //bottom up processing of syntax tree by evaluating the expression...
  //deals with or-operator
  SyntaxTreeNode* expression_eval(const string& expr, int& curr_pos);
  //deals with cat-operator
  SyntaxTreeNode* term_eval(const string& expr, int& curr_pos);
  //deals with star-operator
  SyntaxTreeNode* factor_eval(const string& expr, int& curr_pos);

  int leaves_count_; //number of leaves (positions) in the syntax tree
  vector< unordered_set<int> > follow_pos_; /* for each position in the syntax
                                             * tree, holds a set of positions
                                             * for which there is a word in the
                                             * language that has a reading in
                                             * the syntax tree with these
                                             * positions on consecutive places*/
  vector<char> what_letter_; //what letter is on given position
  map< vector<int>, int > mark_; //holds marked states in dfa construction

  static const unordered_set<char> kLetters; //letters of the alphabet
  static const char kLambda; //lambda symbol
};


#endif //REGEXTODFACONVERTER_REGEX_TO_DFA_H
